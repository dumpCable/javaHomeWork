结论先行：
我们是无良的商人，jvm是苦逼的打工人，我们要jvm不停歇的工作（低延时），同时又需要提高他的产出（高吞吐），
只要干不死就往死里干，我们颁布的各种政策（GC收集器）都是为了保证jvm可以降低延时或者提神吞吐。
从串行SerialGC的一个打工人维护，到并行的ParallelGC的多个打工人处理（利用多核能力），就是为了降低时延
提高吞吐，再到cms的并发标记回收，和G1的化正为零就是为了降低延时。
可以理解为我们一个人先做完A再做B，或者A，B同时做，虽然看上去我们都立马在做（低延时）但是对于单个任务来说，
完成需要的时间就变长了。因此效率就降低了（降低吞吐），
所以我们要立即去做还是要高效完成就按照需要去做。基于分代假设，年轻代特点来的快去的也快，高效率才是首选，拉
长战线可能会导致任务的积压，对于老年代，对象变更慢，对象数量多，占用内存大，我们要一下完成这个任务需要时时
间就变长，因此分阶段做小任务，同时还能保证其他工作的正常开展。
既然分代了，gc算法也会不同，我们就会分YoungGC和OldGC，也是minorGC和majorGC，youngGC标记复制算法，
高效处理，parallel比serial效果好，parNew也是serial的并行版本，G1是整理用的，延时低，对于oldGC，目
前可选比较多serial，parallel，cms，G1（严格来说不算），ZGC（比G1要延时低）。

正常年轻代满了触发youngGC，老年代满了出发fullgc，年轻代满了是正常滴，一般来说对象的实例都是保存在年轻代.
老年代满了有以下几种情况：
1.多次youngGC后年轻代晋升上来的对象占满了老年代，正常情况，但是如果设置的晋升代数（默认15次youngGC）太
短会导致晋升的频率和数据会上升
2.youngGC之后因为复制空间不够（surivor区），导致多余的对象溢出，需要借用old区的内存空间，最后占满old区。
这个时候要考虑是代码程序是否存在问题，如果是正常的业务功能，那么需要增加年轻代的大小解决。
3.大对象young区不会存储，会直接进入old区存储，如果数量多，old区很快就被占满。优先排查应用使用是否存在问题，
解决办法就是增加整个堆空间大小或者是优化代码。
fullgc如果释放不了足够多空间就会导致oom


简要的阐述：
目前jvm的垃圾回收器主要是有串行serialGC，并行parallelGC，还有就是CMS，G1，ZGC
那么怎么会有那么多的垃圾回收器呢？
本质上还是因为性能的问题吞吐和延时的问题。
因为java的特性，无需开发人员像c++那样需要自己去申请和释放内存。大大减少了开发人员的开发难度和成本。同时也保证
了一定的稳定性。虽然内存的管理交给了jvm自行管理。但是内存资源本身是有限。怎么高效分配使用和回收内存，是jvm最关
注的事情。因为这会对应用的处理性能有很大的影响，如果低效或者无法满足日益复杂的业务和高性能的系统，就会被淘汰。
说到垃圾回收器，那么就是关注如果对内存进行高效的回收。因果关系，分配使用是会影响回收的效率。
说到回收，最主要的问题就是怎么判断这个内存是可以被回收或者不能被回收。如果不能被回收的内存回收了，就可能会导致程
序的崩溃，这是致命的。因此判断可回收内存的逻辑就变得尤为关键。那么如何高效的识别可回收的垃圾呢？
首先明确jvm的内存存储的主要有类的基本信息包含方法等，方法执行的本地机器码，常量，静态变量，实例变量，执行的方法
栈空间。如果是说可以回收那么就是会在一段时间后失效的对象，显然，像类信息，常量，方法栈，本地机器码这些新使用的生
命周期一般与jvm相般，那么说我们主要收集的是静态变量实例变量这些，其中实例变量为大部分内存体现。也就是我们明确回
收的区域就是java堆内存。一般而言，如果我们要堆整个java堆内存进行收集，都是需要做两个事情
1.遍历内存中的所有对象。
2.判定对象是否存活。
3.清理废弃的对象
4.整理内存空间（视情况而定，如果不对内存进行整理那么运行久之后就会产生大量内存碎片，如果每次都整理则非常消耗性能）
这是我们不得不做的两件事情，因此想要我们更高效回收就只能从这两个点出发，
针对第一点进行优化：1.如何遍历尽可能少的对象，或者说如何最大可能的命中我们需要回收的对象，
也就是说我们遍历的对象是否是大概率不可回收或者基本不能被回收的，答案是肯定，我们jvm中肯定会存在存在很久的对象或者
压根不会被回收的对象，这部分的对象我们没有必要每次都进行遍历判定，可以减少遍历的数量。而存活较短时间短，这部分的遍
历开销是无法避免的。所以基于这个分代假设理论，我们对堆进行进一步划分，将之划分成年轻代和老年代，老年代区域就是专门
保存存活较长时间的对象，而年轻代保存存活短暂的对象。一般情况下，老年代的对象只能通过年轻代晋升上来。当然也有一些特
殊情况，需要借用老年代的区域，我们后面说明，既然划分了区域，那么有针对性的使用回收算法当然比用同一的算法效率要高的
多。刚刚说了，回收内存除了遍历判定还有回收释放。我们试想一下，对于一个年轻代区域来说，在一次回收标记算法之后会存在
以下几种情况:
1.存活少量对象
2.存活适量对象
3.存活大量对象
对于年轻代而言最理想的回收状态就是1，可以接受2的情况，3情况是不能接受的。
对于情况1.2我们在既然只剩下少量存活对象，那么做整理是达到的收益是非常可观的。我们整理一般都会是向前压缩，
我们有两种方式，一种时向前压缩整理，另外一种是将其复制到其他整块空间，我们是怎么选择的，为什么在年轻代区域不使用标记
清理而是用标记复制呢？我个人的理解是标记复制，只要我判定当天对象可达我就可以复制到新的空间，因为新的空间没有被使用，
所以可以直接复制使用，但是标记清理需要标记哪些是存活对象需要整体标识完才能做清除整理实现上要比复制算法复杂一些，同时
基于分代假设，我们的年轻代，每次存活的对象数量应该都是占少部分，用少量的空间去换时间也比较划算，既然空间复制算法需要
额外的空间，如果我们吧堆划分成两分，每份50%的话，就会有50%的空间造成了浪费，既然存活对象很少这个原则，那么保存存活
对象需要的空间也不用那么大，所以设置1:1:8的比例空间算是比较合理的经验值，两个单独划分出来的1是为了保证每次复制都有
新的空间可以使用。这样子我们整个年轻代实际可以使用的空间应该是整体的90%，而对于老年代来说，对象存活的时间较长，每次
回收之后也是存在以下几种情况
1.存活少量对象
2.存活适量对象
3.存活大量对象
对于老年代来说，第二第三种是比较合适的情况，在分代假设中，老年代对象应该会存活很久，那么每次回收标记应该就会存活很多
对象，当老年代gc之后存活的对象很少不到哦10～20%那是不健康的一种状态，对于老年代来说，标记清除和标记清理都可以使用，
只是前者会产生垃圾碎片，或者会多一步整理的操作需要消耗性能。
针对第二点进行优化：如何减少判定对象存活的次数，我们一般的做法就是根可达分析，为了减少遍历对象的数量，我们可以做一些
优化，比如卡表，Rset记录引起，比如cms的Rset就是记录年轻代指向老年代的对象，G1则是记录老年代到年轻代的指向对象，原
因是年轻代G1会全部遍历一遍
标记无时无刻不在变化，因为jvm一直在运行，那么有没有比较合适的时间点可以准确的标记，想jvm就有一个安全点的概念，所有
线程到达安全点就停止工作，给gc线程提供处理时间，


